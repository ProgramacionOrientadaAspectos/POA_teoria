{
  "name": "Programacion Orientada a Aspectos",
  "tagline": "",
  "body": "# PROGRAMACIÓN ORIENTADA A ASPECTOS.\r\n\r\n\r\n\r\n## CONCEPTOS CLAVES\r\n\r\n###  **ASPECTO(Aspect):**  \r\n“Un aspecto es una **unidad modular que se disemina por la estructura de otras unidades funcionales.** Un aspecto de diseño es una unidad modular del diseño que se entremezcla en la estructura de otras partes del diseño. (G. Kiczales).“\r\n\r\n![](https://github.com/japrietov/POA_teoria-1/blob/gh-pages/Images/Aspecto.png?raw=true)\r\n\r\n###   **PUNTO DE UNIÓN/ENLACE(Joint point):** \r\nPunto de ejecución dentro del sistema donde un aspecto puede ser conectado:\r\n* Llamada a un método\r\n* Lanzamiento de una excepción\r\n* Modificación de un campo.\r\n\r\n![](https://github.com/japrietov/POA_teoria-1/blob/gh-pages/Images/Joinpoints.png?raw=true)\r\n\r\n###   **CONSEJO(Advice):**\r\nEs la implementación del aspecto, es decir, contiene el **código que implementa la nueva funcionalidad**. Se insertan en la aplicación en los Puntos de unión.\r\nDentro de ellos podemos encontrar:\r\n   * **before** : justo antes de proceder al joint-point (ej: justo antes de entrar al getter, o al constructor, etc)\r\n   * **after returning**: justo después del return de un método.\r\n   * **after throwing**: justo después de que lanza una exception.\r\n   * **after**: al salir de un método, sin importar si fue por exception o por flujo normal (return)\r\n   * **around**: cuando el flujo llega a ejecutar el join-point, permite que nuestra lógica pueda determinar si proceder o no.\r\n\r\n###   **PUNTOS DE CORTE(Pointcut):**\r\nDefine los Consejos que se aplicarán a cada Punto de Cruce. Un pointcut es un **predicado o condición para la aplicación de un aspecto.**\r\n\r\n_Se puede entender mas claramente en la siguiente imagen, donde el programa hace un llamado a un advice, el cual se definirá atravez de un pointcut, el cual tendrá diferentes joinpoints del cual podrá escoger uno o varios aspectos para ser ejecutados (Algo enredado, pero mas adelante se explica mejor esa diferenciación entre pointcut y joinpoint..)_\r\n\r\n![](https://github.com/japrietov/POA_teoria-1/blob/gh-pages/Images/advice_pointcut.png?raw=true)\r\n\r\n***\r\n_**VAMOS CON EL EJEMPLO...**_\r\n\r\n_Cuando sales a comer a un restaurante, estando en él, miras el menú y hay varias opciones que se pueden escoger de platos fuertes, ensaladas, postres, etc. Después de ver que hay en el menú escoges uno o mas de estos platos, pero hasta que estos no sean ordenados y el mesero no te los traiga son solo \"oportunidades para cenar\"._\r\n\r\n![](https://github.com/japrietov/POA_teoria-1/blob/gh-pages/Images/example_restaurant.png?raw=true)\r\n\r\n_Los **joinpoints** son las opciones que hay en el menu y los **pointcuts** son los platos que se ordenan. Hablando dentro del ámbito de la programación. Un **joinpoint** es una oportunidad dentro del código para la aplicación de un ASPECTO; una vez se toma esa oportunidad y se selecciona uno o mas joinpoints, al aplicar un ASPECTO de ellos se tendrá un **pointcut**._\r\n\r\n***\r\n\r\n_Pero bueno, a nosotros nos gusta ver como se verían todos estos conceptos aplicados ya en un programa. Supongamos que tenemos una tienda, la cual tendrá diferentes empleados. El administrador de la tienda va a tener todo el manejo de los empleados, incluyendo todas las operaciones CRUD (Create, Read, Update, Delete), hasta Como sera el inicio de sesión a la aplicación por parte de los empleados. Este inicio de sesión o Loggin sera el Aspecto que tendrá nuestra aplicación._\r\n\r\n_La imagen a continuación explicara claramente donde estarían cada uno de los conceptos anteriormente mencionados dentro de un programa. Este programa fue implementado utilizando **Spring AOP + AspectJ**._\r\n\r\n![](https://github.com/ProgramacionOrientadaAspectos/POA_teoria/blob/gh-pages/Images/example_code.png?raw=true)\r\n\r\n_Tal vez aun no quede claro estos conceptos mencionados anteriormente, pero en secciones posteriores encontraran mas ejemplos que ayudaran a entender mejor el paradigma de **Programación Orientada a Aspectos**_\r\n\r\n***\r\n\r\n### **INTRODUCCIÓN(Introduction):**\r\nPermite añadir métodos o atributos a clases ya existentes. Un ejemplo en el que resultaría útil es la creación de un Consejo de Auditoría que mantenga la fecha de la última modificación de un objeto, mediante una variable y un método setUltimaModificacion(fecha), que podrían ser introducidos en todas las clases (o sólo en algunas) para proporcionarles esta nueva funcionalidad. \r\n\r\n\r\n### **DESTINATARIO(Target):**\r\nEs la clase aconsejada, la clase que es objeto de un consejo.\r\n\r\n### **RESULTANTE(Proxy):** \r\nEs el objeto creado después de aplicar el Consejo al Objeto Destinatario.\r\n\r\n***\r\n_Estas definiciones de Target y proxy se entienden mejor en la siguiente imagen, donde claramente se ve que la clase aconsejada o Target es la clase **FooService** y el objeto creado Proxy despues de aplicar ese Concejo es **FooServiceProxy**_\r\n\r\n![](https://github.com/ProgramacionOrientadaAspectos/POA_teoria/blob/gh-pages/Images/proxy_target.png?raw=true)\r\n\r\n***\r\n\r\n### **TEJEDOR(Weaving):**\r\nEl tejedor se encarga de **mezclar los diferentes mecanismos de abstracción y composición** que aparecen en los lenguajes de aspectos y componentes ayudándose de los puntos de enlace.\r\n\r\nEste proceso puede ocurrir a lo largo del ciclo de vida del programa:\r\n * Aspectos en Tiempo de Compilación.\r\n * Aspectos en Tiempo de Carga, los Aspectos se implementan cuando el Objeto Destinatario es cargado.\r\n * Aspectos en Tiempo de Ejecución.\r\n\r\n_Este concepto de Tejedor es muy importante dentro de la Programación Orientada a Aspectos, este es el que nos va a mezclar el **Programa de componentes** descrito por un Lenguaje base, y  los diferentes **Programas de Aspectos**, cada uno descrito por su propio Lenguaje de aspectos_\r\n\r\n![](https://github.com/ProgramacionOrientadaAspectos/POA_teoria/blob/gh-pages/Images/Tejedor.png?raw=true)\r\n\r\n***\r\n\r\nVIENDO TODOS ESTOS CONCEPTOS ANTERIORMENTE MENCIONADOS, SE PUEDE PUEDE VER LA DIFERENCIA EN LA ESTRUCTURA DE LA IMPLEMENTACIÓN ENTRE **LOS LENGUAJES TRADICIONALES** Y **LOS LENGUAJES DE ASPECTOS**\r\n\r\n![](https://github.com/ProgramacionOrientadaAspectos/POA_teoria/blob/gh-pages/Images/Diferencia_tradicional_aspectos.png?raw=true)\r\n\r\nCOMO SE VE, EL CONCEPTO DEL _TEJEDOR_ SE VUELVE FUNDAMENTAL EN LA PROGRAMACIÓN ORIENTADA A ASPECTOS. ADEMÁS QUE LA IMPLEMENTACIÓN DEJA DE SER UNA IMPLEMENTACIÓN SECUENCIAL Y PASA A SER UNA IMPLEMENTACIÓN MODULARIZADA.\r\n\r\n***\r\n\r\n## VENTAJAS Y DESVENTAJAS\r\n\r\n###  **VENTAJAS**  \r\n\r\n* Ayuda a superar los problemas causados por: **Código Mezclado(Code Tangling)** y **Código Diseminado(Code Scattering)**\r\n\r\n***\r\n![](https://github.com/ProgramacionOrientadaAspectos/POA_teoria/blob/gh-pages/Images/scattering_tangling.png?raw=true)\r\n\r\n_Se entiende como **Código Mezclado** como en un mismo módulo de un sistema de software puedan simultáneamente convivir más de un requerimiento. Esta múltiple existencia de requerimientos lleva a la presencia conjunta de elementos de implementación de más de un requerimiento, resultando en un Código Mezclado._\r\n\r\n_El **Código Diseminado** se refiere a como los requerimientos están esparcidos sobre varios módulos, la implementación resultante también queda diseminada sobre esos módulos._\r\n***\r\n\r\n* **Implementación modularizada:** POA logra separar cada concepto con mínimo acoplamiento, resultando en implementaciones  modularizadas aún en la presencia de conceptos que se entrecruzan. Esto lleva a un código más limpio, menos duplicado, más fácil de entender y de mantener.\r\n\r\n* **Mayor evolucionabilidad:** La separación de conceptos permite agregar nuevos aspectos, modificar y / o remover aspectos existentes fácilmente.\r\n\r\n![](https://github.com/ProgramacionOrientadaAspectos/POA_teoria/blob/gh-pages/Images/evolucion-social.jpg?raw=true)\r\n\r\n* **Capacidad de retrasar las decisiones de diseño:** para requerimientos actuales o que surjan en el futuro, permite, luego, _implementarlos separadamente, e incluirlos automáticamente en el sistema._\r\n\r\n* **Resuelve el dilema del arquitecto:** ¿Cuántos recursos invertir en el diseño? ¿Cuándo es “demasiado diseño”?\r\n\r\n* **Mayor reusabilidad:** Al ser implementados separadamente, tiene mayor probabilidades de ser reusados en otros sistemas con requerimientos similares. \r\n\r\n![](https://github.com/ProgramacionOrientadaAspectos/POA_teoria/blob/gh-pages/Images/code_reusability.jpg?raw=true)\r\n\r\n* **Divide y vencerás:** Al separar la funcionalidad básica de los aspectos, se aplica con mayor intensidad el principio de dividir y conquistar.\r\n\r\n* **N-dimensiones:** Ahora se tiene la posibilidad de implementar el sistema con las dimensiones que sean necesarias, no una única dimensión ”sobrecargada”.\r\n\r\n* **Mínimo acoplamiento y máxima cohesión:** Se genera una mejor implementación de un sistema si realizamos cada una de sus partes por separado y los unimos de una manera estrecha en donde estas partes, en este caso los aspectos interactúen adecuadamente.\r\n\r\n![](https://github.com/ProgramacionOrientadaAspectos/POA_teoria/blob/gh-pages/Images/minimo_acoplamiento_maxima_cohesion.png?raw=true)\r\n\r\n###  **DESVENTAJAS**  \r\n\r\n* **Posibles choques entre el código funcional (expresado en el lenguaje componente) y el código de aspectos (expresados en los lenguajes de aspectos):** Usualmente estos choques nacen de la necesidad de violar el encapsulamiento para implementar los diferentes aspectos, sabiendo de antemano el riesgo potencial que se corre al utilizar estas prácticas.\r\n\r\n* **Posibles choques entre los aspectos:** El ejemplo clásico es tener dos aspectos que trabajan perfectamente por separado pero al aplicarlos conjuntamente resultan en un comportamiento anormal. \r\n\r\n![](https://github.com/ProgramacionOrientadaAspectos/POA_teoria/blob/gh-pages/Images/choque.png?raw=true)\r\n\r\n* **Posibles choques entre el código de aspectos y los mecanismos del lenguaje:** Uno de los ejemplos más conocidos de este problema es la anomalía de herencia. Dentro del contexto de la POA, el término puede ser usado para indicar la dificultad de heredar el código de un aspecto en la presencia de herencia.\r\n\r\n![](https://github.com/ProgramacionOrientadaAspectos/POA_teoria/blob/gh-pages/Images/herencia.png?raw=true)\r\n\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}